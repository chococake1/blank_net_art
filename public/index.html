<!doctype html>
<head>
    <title>squares dreaming</title>
<style>
    body, html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    #colorSquare {
        width: 100px;
        height: 100px;
        background-color: red;
        position: absolute;
    }
/*     #canvas {
        border: 1px solid black;
    } */
</style>
</head>

<body>
<canvas id="canvas"></canvas>

<div id="colorSquare"></div>

<script type="module">
    // Get the canvas element and its 2D rendering context
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Set canvas width and height to fill the window
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Square properties
    let squareSize = 240; //Squares are 240 pixels big
    let squareX = Math.random() * (canvas.width - squareSize); // Random initial x position
    let squareY = Math.random() * (canvas.height - squareSize); // Random initial y position
    let dx = 8; // 4 times faster
    let dy = 8; // 4 times faster

    // Color change interval
    const colorChangeInterval = 4; // Colour changes every 4 frames
    let frameCount = 0;

    // Arrays to store previous positions and colors for trail effect
    const trailPositions = [];
    const trailColors = [];

    // Function to generate a random color
    function randomColor() {
        return '#' + Math.floor(Math.random() * 16777215).toString(16);
    }

    // Function to draw a square on the canvas
    function drawSquare(x, y, size, color) {
        ctx.fillStyle = color; // Set fill color
        ctx.fillRect(x, y, size, size); // Draw filled rectangle
    }

    let isRunning = true; // Boolean variable to control animation

    // Function to animate the square
    function animate() {
        if (!isRunning) return; // Check if animation is paused

        frameCount++; // Increment frame count

        // Change color every colorChangeInterval frames
        if (frameCount % colorChangeInterval === 0) {
            // Generate a random color for the square
            const color = randomColor();

            // Add current position and color to arrays for trail effect
            trailPositions.push({ x: squareX, y: squareY });
            trailColors.push(color);
        }

        // Move the square
        squareX += dx; // Move horizontally
        squareY += dy; // Move vertically

        // Bounce off the edges if the square hits the canvas boundaries
        if (squareX + squareSize > canvas.width || squareX < 0) {
            dx = -dx; // Reverse horizontal direction
        }
        if (squareY + squareSize > canvas.height || squareY < 0) {
            dy = -dy; // Reverse vertical direction
        }

        // Clear canvas before drawing the next frame
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw trail
        for (let i = 0; i < trailPositions.length; i++) {
            const { x, y } = trailPositions[i]; // Get position from array
            const color = trailColors[i]; // Get color from array
            drawSquare(x, y, squareSize, color); // Draw square at position with color
        }

        // Request next animation frame to continue animation loop
        requestAnimationFrame(animate);
    }

    // Start the animation loop
    animate();

    // Function to pause/resume animation when canvas is clicked
    function toggleAnimation() {
        isRunning = !isRunning; // Toggle animation state
        if (isRunning) {
            animate(); // If animation is resumed, call animate function to continue animation loop
        }
    }

    // Event listener for click on canvas to toggle animation
    canvas.addEventListener('click', function() {
        toggleAnimation(); // When canvas is clicked, toggle animation state
    }, false);
</script>

<canvas id="pixel_sort"></canvas>

<script type="module">
   import { PixelSorter } from "/scripts/pixel_sort.js"

   const cnv  = document.getElementById (`pixel_sort`)
   cnv.width  = cnv.parentNode.scrollWidth
   cnv.height = cnv.width * 9 / 16   

   const ctx = cnv.getContext (`2d`)
   const sorter = new PixelSorter (ctx)

   const img = new Image ()

   img.onload = () => {
      cnv.height = cnv.width * (img.height / img.width)
      ctx.drawImage (img, 0, 0, cnv.width, cnv.height)
      sorter.init ()
      draw_frame ()
   }

   img.src = `/images/background_test.jpg`

   let frame_count = 0
   const draw_frame = () => {

      ctx.drawImage (img, 0, 0, cnv.width, cnv.height)

      let sig = Math.cos (frame_count * 2 * Math.PI / 500)

      const mid = {
         x: cnv.width / 2,
         y: cnv.height / 2
      }

      const dim = {
         x: Math.floor ((sig + 3) * (cnv.width / 6)) + 1,
         y: Math.floor ((sig + 1) * (cnv.height / 6)) + 1
      }

      const pos = {
         x: Math.floor (mid.x - (dim.x / 2)),
         y: Math.floor (mid.y - (dim.y / 2))
      }

      sorter.glitch (pos, dim)

      frame_count++
      requestAnimationFrame (draw_frame)
   }

</script>
</body>
