<!doctype html>
<head>
    <title> b l a n k </title>
<style>
    body, html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    #colorSquare {
        width: 100px;
        height: 100px;
        background-color: red;
        position: absolute;
    }
    #canvas {
        border: 1px solid black;
    }
</style>
</head>

<body>
<canvas id="canvas"></canvas>


<div id="colorSquare"></div>

<script type="module">
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Set canvas width and height
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Square properties
    let squareSize = 240; // 8 times bigger
    let squareX = Math.random() * (canvas.width - squareSize);
    let squareY = Math.random() * (canvas.height - squareSize);
    let dx = 8; // 4 times faster
    let dy = 8; // 4 times faster

    // Color change interval
    const colorChangeInterval = 4; // Change color every 4 frames
    let frameCount = 0;

    // Array to store previous positions and colors
    const trail = [];

    // Function to generate a random color
    function randomColor() {
        return '#' + Math.floor(Math.random() * 16777215).toString(16);
    }

    // Function to draw a square
    function drawSquare(x, y, size, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, size, size);
    }

    function animate() {
        frameCount++;

        // Change color every colorChangeInterval frames
        if (frameCount % colorChangeInterval === 0) {
            // Generate a random color for the square
            const color = randomColor();

            // Add current position and color to trail
            trail.push({ x: squareX, y: squareY, color: color });
        }

        // Move the square
        squareX += dx;
        squareY += dy;

        // Bounce off the edges
        if (squareX + squareSize > canvas.width || squareX < 0) {
            dx = -dx;
        }
        if (squareY + squareSize > canvas.height || squareY < 0) {
            dy = -dy;
        }

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw trail
        for (let i = 0; i < trail.length; i++) {
            const { x, y, color } = trail[i];
            drawSquare(x, y, squareSize, color);
        }

        requestAnimationFrame(animate);
    }

    animate();
</script>

<script type="module">
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Set canvas width and height
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Function to get combined RGB value from pixel data
    function getRGBValue(r, g, b) {
        return r * 65536 + g * 256 + b;
    }

    // Function to sort pixels by RGB value
    function sortPixelsByColor(data) {
        const pixels = [];

        // Convert pixel data to objects with combined RGB value and original index
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const rgbValue = getRGBValue(r, g, b);
            pixels.push({ rgbValue, index: i });
        }

        // Sort pixels by combined RGB value
        pixels.sort((a, b) => a.rgbValue - b.rgbValue);

        // Rearrange pixel data based on sorted indices
        const newData = new Uint8ClampedArray(data.length);
        pixels.forEach((pixel, i) => {
            const dataIndex = pixel.index;
            const pixelIndex = i * 4;
            newData[pixelIndex] = data[dataIndex];
            newData[pixelIndex + 1] = data[dataIndex + 1];
            newData[pixelIndex + 2] = data[dataIndex + 2];
            newData[pixelIndex + 3] = data[dataIndex + 3];
        });

        return newData;
    }

    // Function to sort pixels within the square at the given position
    function sortPixelsAtPosition(x, y) {
        const squareSize = 100;

        // Get pixel data within the square centered at the given position
        const imageData = ctx.getImageData(x - squareSize/2, y - squareSize/2, squareSize, squareSize);
        const sortedData = sortPixelsByColor(imageData.data);

        // Put sorted pixel data back to the canvas
        ctx.putImageData(new ImageData(sortedData, squareSize, squareSize), x - squareSize/2, y - squareSize/2);
    }

    // Event listener for click event on canvas
    canvas.addEventListener('click', function(event) {
        const x = event.clientX;
        const y = event.clientY;
        
        // Sort pixels at the clicked position
        sortPixelsAtPosition(x, y);
    });

</script>
    
</body>


<!-- <script type="module">
    const cnv = document.getElementById (`recursive_squares`)
    cnv.width = cnv.parentNode.scrollWidth
    cnv.height = cnv.width
    
    const ctx = cnv.getContext (`2d`)

    function rand_col () {
        return `hsl(${ Math.random () * 360 }, 100%, 66%)`
    }

    function draw_square (size) {
        const x = (cnv.width - size) / 2
        const y = (cnv.height - size) / 2

        ctx.fillStyle = rand_col ()
        ctx.fillRect (x, y, size, size)
    }

    function draw_squares (start_size) {
        draw_square (start_size)

        if (start_size > 0) {
            draw_squares (start_size - 20)
        }
    }

    draw_squares (cnv.height)

</script> -->
